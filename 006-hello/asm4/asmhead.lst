     1 00000000                                 ; haribote-os
     2 00000000                                 ; TAB=4
     3 00000000                                 [INSTRSET "i486p"]	;; 要想使用486指令
     4 00000000                                 ; 之后的汇编指令将会被翻译成32位机器码
     5 00000000                                 
     6  = 00280000                              BOTPAK  EQU 0x00280000	; bootpack的加载目标地址
     7  = 00100000                              DSKCAC  EQU 0x00100000	; 磁盘缓存位置，1MB
     8  = 00008000                              DSKCAC0 EQU 0x00008000	; ipl中加载10个柱面的位置0x8200
     9 00000000                                 
    10 00000000                                 ; boot_info的信息保存地址（目前仍未被使用的地址）
    11  = 00000FF0                              CYLS EQU 0x0ff0		; 指定扇区
    12  = 00000FF1                              LEDS EQU 0x0ff1		;
    13  = 00000FF2                              VMODE EQU 0x0ff2		;用于记录颜色的信息，颜色的位数
    14  = 00000FF4                              SCRNX EQU 0x0ff4		;分辨率X
    15  = 00000FF6                              SCRNY EQU 0x0ff6		;分辨率Y
    16  = 00000FF8                              VRAM EQU 0x0ff8		;图像缓冲区的起始地址,video ram
    17 00000000                                 					;显存，用于显示画面
    18 00000000                                 	;0x100 :  640 x  400
    19 00000000                                 	;0x101:640*480
    20 00000000                                 	;0x103:800*600
    21 00000000                                 	;0x105:1024*768
    22 00000000                                 	;0x107 : 1280 x 1024
    23  = 00000105                              VBEMODE EQU 0x105	;1024*768
    24 00000000                                 
    25                                          	ORG		0xc200	; 用于告知编译器要被放入内存的地方
    26 0000C200                                 
    27 0000C200                                 	;确认VBE是否纯在，VESA BIOS EXTENSION
    28 0000C200 B8 9000                         	mov ax,0x9000	;vbe会将显卡信息写入[es:di]开始的512B中
    29 0000C203 8E C0                           	mov es,ax
    30 0000C205 BF 0000                         	mov di,0
    31 0000C208 B8 4F00                         	mov ax,0x4f00
    32 0000C20B CD 10                           	int 0x10
    33 0000C20D 3D 004F                         	cmp ax,0x004f	;如果ax不是0x4f，则意味不支持vbe
    34 0000C210 75 52                           	jne scrn320
    35 0000C212                                 	
    36 0000C212                                 	;检查vbe版本
    37 0000C212 26 8B 45 04                     	mov ax,[es:di+4]
    38 0000C216 3D 0200                         	cmp ax,0x0200
    39 0000C219 72 49                           	jb scrn320	; if (AX < 0x0200) ,vbe的版本是不是在2.0以上
    40 0000C21B                                 
    41 0000C21B                                 	;获取画面模式信息
    42 0000C21B B9 0105                         	mov cx,VBEMODE
    43 0000C21E B8 4F01                         	mov ax,0x4f01
    44 0000C221 CD 10                           	int 0x10
    45 0000C223 3D 004F                         	cmp ax,0x004f
    46 0000C226 75 3C                           	jne scrn320
    47 0000C228                                 	
    48 0000C228                                 	;画面模式信息的确认
    49 0000C228 26 80 7D 19 08                  	cmp byte [es:di+0x19],8	;颜色位数是否为8，必须为8
    50 0000C22D 75 35                           	jne scrn320
    51 0000C22F 26 80 7D 1B 04                  	cmp byte [es:di+0x1b],4	;颜色的指定模式是否为4，调色板模式，必须为4
    52 0000C234 75 2E                           	jne scrn320
    53 0000C236 26 8B 05                        	mov ax,[es:di+0x00]
    54 0000C239 25 0080                         	and ax,0x0080	;判断模式位的bit7是否为0
    55 0000C23C 74 26                           	jz scrn320
    56 0000C23E                                 	
    57 0000C23E                                 	;画面模式的切换
    58 0000C23E                                 	; VBE画面模式；ax=0x4f02, bx=模式号码+0x4000
    59 0000C23E BB 4105                         	mov bx,VBEMODE+0x4000
    60 0000C241 B8 4F02                         	mov ax,0x4f02
    61 0000C244 CD 10                           	int 0x10
    62 0000C246                                 
    63 0000C246 C6 06 0FF2 08                   	mov byte [VMODE],8	;保存颜色信息
    64 0000C24B 26 8B 45 12                     	mov ax,[es:di+0x12]
    65 0000C24F A3 0FF4                         	mov [SCRNX],ax
    66 0000C252 26 8B 45 14                     	mov ax,[es:di+0x14]
    67 0000C256 A3 0FF6                         	mov [SCRNY],ax
    68 0000C259 66 26 8B 45 28                  	mov eax,[es:di+0x28]
    69 0000C25E 66 A3 0FF8                      	mov [VRAM],eax
    70 0000C262 EB 20                           	jmp keystatus	;查询键盘状态
    71 0000C264                                 	
    72 0000C264                                 scrn320:
    73 0000C264 B0 13                           	mov al,0x13
    74 0000C266 B4 00                           	mov ah,0x00
    75 0000C268 CD 10                           	int 0x10
    76 0000C26A C6 06 0FF2 08                   	mov byte [VMODE],8
    77 0000C26F C7 06 0FF4 0140                 	mov word [SCRNX],320
    78 0000C275 C7 06 0FF6 00C8                 	mov word [SCRNY],200
    79 0000C27B 66 C7 06 0FF8 000A0000          	mov dword [VRAM],0x000a0000
    80 0000C284                                 	
    81 0000C284                                 keystatus:
    82 0000C284 B4 02                           	mov ah,0x02
    83 0000C286 CD 16                           	int 0x16	;keyboard bios
    84 0000C288 A2 0FF1                         	mov [LEDS],al
    85 0000C28B                                 	
    86 0000C28B                                 ; 用BIOS取得键盘上各个LED指示灯的状态
    87 0000C28B B4 02                           	mov ah,0x02	;2号功能?用
    88 0000C28D                                 				;键盘上各特殊功能按键的状态。
    89 0000C28D                                 				;状态放入AL寄存器中
    90 0000C28D CD 16                           	int 0x16	;keyboard bios
    91 0000C28F A2 0FF1                         	mov [LEDS],al;
    92 0000C292                                 	
    93 0000C292                                 	
    94 0000C292                                 ; PIC关闭一切中断
    95 0000C292                                 ;	根据AT兼容机的规格，如果要初始化PIC
    96 0000C292                                 ;	必须在CLI之前进行，否则有时会挂起
    97 0000C292                                 ;	随后进行PIC的初始化(Programmable Interrupt Controller)
    98 0000C292                                 
    99 0000C292                                 ; 如果在切换模式的（指从实模式切换至保护模式）过程中发生了中断，
   100 0000C292                                 ; CPU是不能停下来去处理中断的（因为处理的方式都没有切换过来），
   101 0000C292                                 ; 所以，在这之前，需要关闭中断。
   102 0000C292                                 ; 两句out指令用于屏蔽主PIC和从PIC的中断发送，
   103 0000C292                                 ; CLI用于停止CPU级别的中断。
   104 0000C292                                 ; NOP指令使得CPU空转一个时钟周期，这是
   105 0000C292                                 ; 为了防止两句OUT连用存在的隐患（例如没有优化到位的竞争冒险）。
   106 0000C292 B0 FF                           	mov al,0xff
   107 0000C294 E6 21                           	out 0x21,al ; 访问外设单独提供了in/out指令,0x21为PIC外设端口地址
   108 0000C296 90                              	nop			;不能够立即执行下一条out指令
   109 0000C297 E6 A1                           	out 0xa1,al ; 设置中断位（应该是的）
   110 0000C299 FA                              	cli		;CLI 禁止中断发,只能在内核模式下执行
   111 0000C29A                                 	
   112 0000C29A                                 	
   113 0000C29A                                 ; 为了让CPU能够访问1MB以上的内存空间，设定A20GATE
   114 0000C29A                                 ;;A20GATE信号线变为on，使得内存中1MB以上的部分变为可用的状态
   115 0000C29A E8 00B5                         	call waitkbdout ;初始化键盘数据，启动键盘控制电路。
   116 0000C29D                                 	
   117 0000C29D B0 D1                           	mov al,0xd1
   118 0000C29F E6 64                           	out 0x64,al		;开启1M以上的内存空间
   119 0000C2A1                                 	;在x86（以及x86以后）的架构中，计算机刚启动时都必须
   120 0000C2A1                                 	;进入实模式，而为了使用这个模式，就不得不先把1MB以外
   121 0000C2A1                                 	;的内存屏蔽掉，使得此时的状态能够模拟出8086时的工作状态，
   122 0000C2A1                                 	;换句话说就是为了向下兼容，在软件级别上使得其与8086工作
   123 0000C2A1                                 	;模式相同。而这条out指令将会使得A20GATE信号线转为1状态
   124 0000C2A1                                 	;（也就是禁止其抑制状态），也就开启了大内存的支持
   125 0000C2A1                                 	
   126 0000C2A1                                 	
   127 0000C2A1 E8 00AE                         	call waitkbdout
   128 0000C2A4 B0 DF                           	mov al,0xdf		; enable a20
   129 0000C2A6 E6 60                           	out 0x60,al		;写60h端口，写input buffer
   130 0000C2A8 E8 00A7                         	call waitkbdout
   131 0000C2AB                                 	
   132 0000C2AB                                 	
   133 0000C2AB                                 ; 实地址模式和虚地址模式的区别：在于计算内存地址时，
   134 0000C2AB                                 ;是使用段寄存器作为地址一部分，还是通过GDT使用段寄
   135 0000C2AB                                 ;存器的值来指定并非实际存在的地址
   136 0000C2AB                                 ; 切换到保护模式
   137 0000C2AB                                 
   138 0000C2AB                                 	;由于保护模式和实模式寻址方式不同，
   139 0000C2AB                                 	;要想使得段寄存器有效，就必须使用GDT
   140 0000C2AB 0F 01 16 C39A                   	lgdt [GDTR0]	;设定临时的GDT
   141 0000C2B0                                 	;设置了CR0之后，便正式进入保护模式
   142 0000C2B0 0F 20 C0                        	mov eax,cr0
   143 0000C2B3 66 25 7FFFFFFF                  	and eax,0x7fffffff	; bit31设为0
   144 0000C2B9 66 83 C8 01                     	or eax,0x00000001	; bit0设为1，（为了切换到保护模式）
   145 0000C2BD 0F 22 C0                        	mov cr0,eax
   146 0000C2C0                                 	
   147 0000C2C0                                 	;由于保护模式的机器语言会采用流水线机制，
   148 0000C2C0                                 	;会预先解释下面的指令，但是，由于刚刚转换成保护模式，
   149 0000C2C0                                 	;下面的一条语句还是按照以前的方式来解释的，
   150 0000C2C0                                 	;直接去执行会出错，所以专门加一条jmp指令是为了容错，
   151 0000C2C0                                 	;让计算机重新解释一遍后面的语句，防止奇怪的bug
   152 0000C2C0 EB 00                           	jmp pipelineflush
   153 0000C2C2                                 	
   154 0000C2C2                                 pipelineflush:
   155 0000C2C2 B8 0008                         	mov ax,1*8	;	//0x0008
   156 0000C2C5 8E D8                           	mov ds,ax	;	//相当于gdt+1段
   157 0000C2C7 8E C0                           	mov es,ax	;
   158 0000C2C9 8E E0                           	mov fs,ax	;80386起增加的两个辅助段寄存器,fs,gs
   159 0000C2CB 8E E8                           	mov gs,ax	;减轻ES寄存器的负担
   160 0000C2CD 8E D0                           	mov ss,ax
   161 0000C2CF                                 	
   162 0000C2CF                                 ; bootpack的传送
   163 0000C2CF                                 ; 把将来将要写的操作系统内核的部分加载到内存
   164 0000C2CF 66 BE 0000C3A0                  	mov esi,bootpack ; 源地址
   165 0000C2D5 66 BF 00280000                  	mov edi,BOTPAK	 ; 传送那个目的地址
   166 0000C2DB 66 B9 00020000                  	mov ecx,512*1024/4		; 数据传送的单位是4字节
   167 0000C2E1 E8 0077                         	call memcpy
   168 0000C2E4                                 
   169 0000C2E4                                 ; 磁盘数据最终转送到它本来的位置去
   170 0000C2E4                                 ; 首先从启动扇区开始,将启动扇区复制到1MB以后的内存
   171 0000C2E4 66 BE 00007C00                  	mov esi,0x7c00
   172 0000C2EA 66 BF 00100000                  	mov edi,DSKCAC
   173 0000C2F0 66 B9 00000080                  	mov ecx,512/4
   174 0000C2F6 E8 0062                         	call memcpy
   175 0000C2F9                                 
   176 0000C2F9                                 ; 所有剩下的
   177 0000C2F9 66 BE 00008200                  	mov esi,DSKCAC0+512
   178 0000C2FF 66 BF 00100200                  	mov edi,DSKCAC+512
   179 0000C305 66 B9 00000000                  	mov ecx,0
   180 0000C30B 8A 0E 0FF0                      	mov cl,byte [CYLS]
   181 0000C30F 66 69 C9 00001200               	imul ecx,512*18*2/4	;从柱面数变换为字节数除以4
   182 0000C316                                 						; 512*扇区数*正反面
   183 0000C316 66 81 E9 00000080               	sub ecx,512/4	;减去IPL
   184 0000C31D E8 003B                         	call memcpy
   185 0000C320                                 	
   186 0000C320                                 ; 必须由asmhead来完成的工作，至此全部完毕
   187 0000C320                                 ;	以后交由bootpack完成
   188 0000C320                                 
   189 0000C320                                 ; bootpack的启动,解析系统文件头
   190 0000C320                                 ; 对文件头进行分析，找出合适的执行切入点，
   191 0000C320                                 ; 才可以把用C语言的入口函数加载到需要的地方
   192 0000C320 66 BB 00280000                  	mov ebx,BOTPAK
   193 0000C326 67 66 8B 4B 10                  	mov ecx,[ebx+16]	; bootpack.hrb之后的16号地址，值是0x11a8
   194 0000C32B 66 83 C1 03                     	add ecx,3
   195 0000C32F 66 C1 E9 02                     	shr ecx,2	;ecx/=4;
   196 0000C333 74 10                           	jz skip		;没有要传送的东西时
   197 0000C335                                 	
   198 0000C335                                 	; 将bootpack.hrb的第0x10c8字节开始的0x11a8字节复制到0x310000
   199 0000C335 67 66 8B 73 14                  	mov esi,[ebx+20]	; bootpack.hrb之后的20号地址，值是0x10c8
   200 0000C33A 66 01 DE                        	add esi,ebx
   201 0000C33D 67 66 8B 7B 0C                  	mov edi,[ebx+12]	; bootpack.hrb之后的12号地址，值是0x310000
   202 0000C342 E8 0016                         	call memcpy
   203 0000C345                                 	
   204 0000C345                                 ; 跳转到刚才已经加载合适的程序部分
   205 0000C345                                 skip:
   206 0000C345 67 66 8B 63 0C                  	mov esp,[ebx+12]	;栈初始值
   207 0000C34A 66 EA 0000001B 0010             	jmp dword 2*8:0x0000001b	
   208 0000C352                                 	;2*8用于表示GDT的第二段，第二段地址为0x280000，即bootpack.hrb的开始BOTPAK
   209 0000C352                                 	;然后跳转到0x28001b的地方开始执行，即bootpack的0x1b地方开始执行
   210 0000C352                                 	
   211 0000C352                                 ; 清除缓冲器数据，把键盘缓冲区中的数据转移出来，
   212 0000C352                                 ; 并且清空，循环读取直至控制器数据为0，跳出函数体
   213 0000C352                                 waitkbdout:
   214 0000C352 E4 64                           	in al,0x64
   215 0000C354 24 02                           	and al,0x02
   216 0000C356 E4 60                           	in al,0x60	; 空读（为了清空数据接收缓冲区中的垃圾数据，键盘，鼠标的数据）
   217 0000C358 75 F8                           	jnz waitkbdout ; AND的结果如果不是0，就跳到waitkbdout
   218 0000C35A C3                              	ret
   219 0000C35B                                 	
   220 0000C35B                                 ; 将以ESI数据为首地址的内存数据传送到
   221 0000C35B                                 ; 以EDI数据为首地址的内存中，传送数据的大小是ECX中的值
   222 0000C35B                                 memcpy:
   223 0000C35B 67 66 8B 06                     	mov eax,[esi]
   224 0000C35F 66 83 C6 04                     	add esi,4
   225 0000C363 67 66 89 07                     	mov [edi],eax
   226 0000C367 66 83 C7 04                     	add edi,4
   227 0000C36B 66 83 E9 01                     	sub ecx,1
   228 0000C36F 75 EA                           	jnz memcpy
   229 0000C371 C3                              	ret
   230 0000C372                                 	
   231 0000C372                                 
   232 0000C372                                 ; GDT: global segment descriptor table
   233 0000C372                                 ; 指定段的寄存器只有16位(低三位不能用)，但是在32位模式下，每一个段需要64位描述符
   234 0000C372                                 ; 用于指明段大小，段起始地址，段权限等信息
   235 0000C372                                 ; 为此在内存中设计一个描述表，共8192（2^13）个表项，每个表项64位
   236 0000C372                                 ; IDT: interrupt descriptor table
   237 0000C372                                 ; IDT中记录了0-255个中断号和中断处理程序之间的对应关系
   238 0000C372 00 00 00 00 00 00 00 00 00 00   	alignb 16
       0000C37C 00 00 00 00 
   239 0000C380                                 	
   240 0000C380                                 	;GDT0是一种特殊的GDT，
   241 0000C380                                 GDT0:						
   242 0000C380 00 00 00 00 00 00 00 00         	resb 8	;null selector		    ; 0号是空区域，不能够用于定义段
   243 0000C388                                 	;set_segmdesc(gdt+1,0xffffffff,0x00000000,AR_DATA32_RW);
   244 0000C388 FFFF 0000 9200 00CF             	DW	0xffff,0x0000,0x9200,0x00cf	; 可以读写的段（segment）32bit
   245 0000C390                                 	;set_segmdesc(gdt+2,LIMIT_BOTPAK,ADR_BOTPAK,AR_CODE32_ER);
   246 0000C390 FFFF 0000 9A28 0047             	DW	0xffff,0x0000,0x9a28,0x0047	; 可以执行的段（segment）32bit（bootpack用）
   247 0000C398 0000                            	DW	0 
   248 0000C39A                                 	
   249 0000C39A                                 GDTR0:
   250 0000C39A 0017                            	dw 8*3-1
   251 0000C39C 0000C380                        	dd GDT0
   252 0000C3A0                                 	
   253 0000C3A0                                 	alignb 16
   254 0000C3A0                                 bootpack:
